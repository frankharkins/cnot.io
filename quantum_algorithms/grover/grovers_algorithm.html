<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- /Bootstrap CSS -->
    <link rel="stylesheet" href="/Bootstrap/css/bootstrap.css" media="screen">

    <title>Grover's Algorithm | CNOT</title>
	<link rel="icon" type="image/x-icon" href="/favicons/favicon.ico">
  </head>
  <body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <a class="navbar-brand" href="/">CNOT</a>
        <a href="/navigation/">
        <button class="navbar-toggler"  type="button" data-toggle="collapse" data-target="#navbarTogglerDemo01" aria-controls="navbarTogglerDemo01" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button></a>
  <div class="collapse navbar-collapse" id="navbarTogglerDemo01">
    <ul class="navbar-nav mr-auto mt-2 mt-lg-0">
      <li class="nav-item">
        <a class="nav-link" href="/get_started/">Get Started</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="/about/">About</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="/contents/">Contents</a>
      </li>
    </ul>
    </div>
    </nav>
    <div class='container'>
    <h1><a href="../grover/" style="text-decoration: none">Grover's Algorithm</a></h1>
        <div class="btn-group btn-group" style="margin: 2em" id="list">
            <a href="preamble.html" style="font-size: 1.2em" class="btn btn-default">Previous</a>
            <a href="../grover/" style="font-size: 1.2em" class="btn btn-default">Index</a>
            <a href="using_grovers_algorithm.html" style="font-size: 1.2em; margin-left: .2em" class="btn btn-default"> Next</a>
        </div>
    <h2>The Actual Algorithm</h2>
    <p>Here we go through the basic steps of the algorithm and explain how they can be implemented as a simple quantum circuit.</p>
    <p><br></p>
    <h3>Contents</h3>
        <ul id="list">
                    <li><a href="#outline">Outline</a></li>
                    <li><a href="#implementing_as_a_quantum_circuit">Implementing as a Quantum Circuit</a></li>
                    <ul>
                    <li><a href="#the_oracle">The Oracle</a></li>
                    <li><a href="#the_diffusion_operator">The Diffusion Operator</a></li>
                    <li><a href="#full_quantum_circuit">Full Quantum Circuit</a></li>
                    <li><a href="#quirk_example_circuit">Example Circuit in Quirk</a></li>
                    </ul>
        </ul>
    <p><br></p>
    <h3 id="outline">Outline</h3>
    <p>Here we will quickly describe Grover’s algorithm in a high-level way.</p>    <p>
    The first step of the algorithm is to initialise the starting state |s⟩, a superposition of all possible inputs. We know this can be easily accomplished using a Hadamard transform on each qubit.</p>
    <p><br></p>
    <div class="row">
    <div class="mx-auto text-center">
        <img src="img/fig4.png" style="width:50%; margin-bottom: 2em" title="The intital state is an equal superposition of all measureable inputs, and is easily constructed from Hadamard transforms." >
    </div>
    </div>
    <br>
    <p>Since we want our algorithm to output ω, we want our qubits to be as close to the state |ω⟩ as possible when we measure them. The algorithm is tasked with moving the state of the qubits from |s⟩ to |ω⟩. To simplify, we can split every state in our computation into one of two categories: |ω⟩ and not |ω⟩. Since we only care about |ω⟩ and all the states that are not |ω⟩, we can plot this on a 2D graph:</p>
    <br>
    <div class="row">
    <div class="mx-auto text-center">
        <img src="img/fig5.png" style="width:60%" title="Our qubits start in the state |s⟩, and we are trying to get to |ω⟩" >
    </div>
    </div>
    <br>        
    <p>Where |s’⟩ is the equal superposition of all states excluding |ω⟩. This means |s’⟩ is perpendicular to |ω⟩. Our computer is never actually in the state |s’⟩ (if it is then we’re doing something very wrong!), we just use |s’⟩ to act as the axis on our graph, and to illustrate the reflections we are doing.</p>
        <p>We perform a reflection around |s’⟩ (this operator is called ‘U<sub>ω</sub>’) and a reflection around |s⟩ (called ‘U<sub>s</sub>’), and repeat until we are close to |ω⟩. This takes &nbsp; ~2<sup>n/2</sup> repetitions.</p>
    <br>
    <div class="row">
    <div class="mx-auto text-center">
        <img src="img/fig6.png" style="width:75%; margin: 2em;" title="The first step of Grover's algorithm is to give a negative phase to the |ω⟩ component of |s⟩, this corresponds to a reflection through |s'⟩. The second step is to perform a reflection through |s⟩" >
    </div>
    </div>
    <p><br></p><br>    
    <h3 id="implementing_as_a_quantum_circuit">Implementing Grover's Algorithm as a Quantum Circuit</h3>
    <p>Here we will go through each step and show how they can be performed by a universal quantum computer. The first step, initialising the state |s⟩ is very simple: We do a Hadamard transform (H-gate) on each qubit, this gives us a uniform superposition of every state.</p><br>
    <div class="mx-auto text-center">
        <img src="img/fig92.png" style="width:20%" title="We need to set up our initial superposition, |s⟩. To do this we apply a H-gate to each qubit" >
    </div><p><br></p>
        

    <h3 id="the_oracle">The Quantum Oracle</h3>
    <h5>(A very cool title)</h5>
    <p>The second operation, the reflection around |s’⟩ is the most interesting step, this is where our query circuit comes in. To perform the reflection, we need a circuit that adds a negative phase to the |ω⟩ component of our vector. </p>
    <div class="mx-auto text-center">
        <img src="img/fig8.png" style="width:25%; margin: 2em;" title="The first step of Grover's algorithm is to give a negative phase to the |ω⟩ component of |s⟩, this corresponds to a reflection through |s'⟩" >
    </div>
    <p>Firstly, we implement our classical query circuit as a quantum circuit, (how we actually do this depends on the problem and we will cover this later,) this means we can pass it our superposition of inputs to get a new equal superposition of output states.</p>
    <p>We then use our checker circuit to add a negative phase to the state we’re searching for. In the image below, our |ω⟩ is the state |0101⟩. This is easy enough to check for, we just use a Toffoli gate with the appropriate controls.</p>
    <div class="mx-auto text-center">
        <img src="img/fig10.png" style="width:40%; margin: 2.5em;" title="We pass |s⟩ through our classical query circuit, and use our checker circuit to invert the phase of our solution" >
    </div>
    <p>But how do we apply the negative phase? Remember that if we apply an X-gate to a qubit in the |-⟩  state, we get back a qubit in the state -|-⟩:</p>
    <div class="mx-auto text-center">
        <img src="img/fig11.png" style="width:20%; margin: 2.5em;" title="Applying an X-gate to a qubit in the state |-⟩ inverts its phase" >
    </div>
    <p>So we use our checker circuit to apply an X-gate to a |-⟩ qubit. We then reverse the classical query circuit to get back our initial |s⟩, except the |ω⟩ component is negative.</p>
    <p>We describe the combined state of the search qubits and the |-⟩ qubit using the Kronecker product (link to section). This explains how the negative phase introduced with the checker circuit applies to the whole state:</p>
    <div class="mx-auto text-center">
        <img src="img/fig12.png" style="width:60%; margin: 3em;" title="The X-gate is only applied to the |-⟩ qubit if our register's state is |ω⟩, therefore a negative phase is only applied to the state |ω⟩" >
    </div>
    <p>And remember that any states that are not |ω⟩ will not activate the checker circuit and will pass through unaffected. This whole circuit is a functioning oracle, it performs a reflection about |s’⟩ as specified in Grover’s algorithm.</p>
    <div class="mx-auto text-center">
        <img src="img/fig13.png" style="width:60%; margin: 3em;" title="A full oracle constructed from a classical query circuit (Uc)" >
    </div><br>
        
    <h3 id="the_diffusion_operator">The Diffusion Operator</h3>
    <p>The next step is the reflection through |s⟩, this step is actually really simple, and is the same for every database search. This reflection is called the ‘Diffusion Operator’. To perform the diffusion operator we need to invert anything perpendicular to |s⟩, and we do this following a similar method to the Oracle. </p>
    <p>We will do the transformation that turns |s⟩ into the all-zeroes vector |000..0⟩, and invert anything that is not |000..0⟩, before transforming back again. Before, we easily created |s⟩ by applying a H-gate to each qubit, if we want to go back the all-zeroes vector we just apply a H-gate to each qubit again.</p>
    <div class="mx-auto text-center">
        <img src="img/fig9.png" style="width:45%; margin: 2.5em;" title="Transforming the all-zeroes state |0000⟩ to the equal superposition state |s⟩ and back." >
        <img src="img/fig93.png" style="width:40%; margin: 2.5em;" title="The first step of Grover's algorithm is to give a negative phase to the |ω⟩ component of |s⟩, this corresponds to a reflection through |s'⟩. The second step is to perform a reflection through |s⟩" >
    </div>
    <p>The whole diffusion operator looks like this:</p>
    <div class="mx-auto text-center">
        <img src="img/fig14.png" style="width:45%; margin: 2.5em;" title="This circuit is a functioning diffuser " >
    </div>
    <p>Note that we have applied a negative phase to all the states that are <i>parallel</i> to |s⟩, not perpendicular as we specified. Since global phase can be ignored <span id='todo'></span>, this is completely equivalent. We now have all the steps required to complete Grover’s algorithm.</p><br>
    <h3 id="full_quantum_circuit">As a full Quantum Circuit</h3>
    <p>We can combine our classical query circuit, checker circuit and diffusion operator to complete the first iteration of Grover’s algorithm:</p>
    <div class="mx-auto text-center">
        <img src="img/fig15.png" style="width:50%; margin: 2.5em;" title="The first step of Grover's algorithm is to give a negative phase to the |ω⟩ component of |s⟩, this corresponds to a reflection through |s'⟩. The second step is to perform a reflection through |s⟩" >
    </div>
    <p>Simple! We then repeat the oracle and diffuser O(√<span style="text-decoration: overline">N</span>) times.</p><br>
    
    <h3 id="quirk_example_circuit">Example Circuit in Quirk</h3>
    <p>Here is an example circuit in Quirk</p>
        <ul style="font-family: 'Source Serif Pro', serif;"><li><a href="http://algassert.com/quirk#circuit={%22cols%22:[[1,%22H%22],[%22~q1m2%22,%22Z%22],[%22%E2%80%A6%22],[%22~5kpj%22,1,%22H%22,%22H%22,%22H%22,%22H%22],[1,1,%22Chance4%22],[%22~lba%22,%22X%22,%22%E2%97%A6%22,%22%E2%80%A2%22,%22%E2%97%A6%22,%22%E2%80%A2%22],[%22~j4g%22,1,%22H%22,%22H%22,%22H%22,%22H%22],[%22~iaka%22,%22X%22,%22%E2%97%A6%22,%22%E2%97%A6%22,%22%E2%97%A6%22,%22%E2%97%A6%22],[%22~3bl0%22,1,%22H%22,%22H%22,%22H%22,%22H%22],[1,1,%22Chance4%22],[%22~lba%22,%22X%22,%22%E2%97%A6%22,%22%E2%80%A2%22,%22%E2%97%A6%22,%22%E2%80%A2%22],[%22~j4g%22,1,%22H%22,%22H%22,%22H%22,%22H%22],[%22~iaka%22,%22X%22,%22%E2%97%A6%22,%22%E2%97%A6%22,%22%E2%97%A6%22,%22%E2%97%A6%22],[%22~3bl0%22,1,%22H%22,%22H%22,%22H%22,%22H%22],[1,1,%22Chance4%22]],%22gates%22:[{%22id%22:%22~5kpj%22,%22name%22:%22Create%20|s%E2%9F%A9%22,%22matrix%22:%22{{1,0},{0,1}}%22},{%22id%22:%22~q1m2%22,%22name%22:%22Create%20|-%E2%9F%A9%22,%22matrix%22:%22{{1,0},{0,1}}%22},{%22id%22:%22~lba%22,%22name%22:%22Oracle%22,%22matrix%22:%22{{1,0},{0,1}}%22},{%22id%22:%22~7b6l%22,%22name%22:%22Diffusion%20Operator%22,%22matrix%22:%22{{1,0},{0,1}}%22},{%22id%22:%22~iaka%22,%22name%22:%22Diffuser%22,%22matrix%22:%22{{1,0},{0,1}}%22},{%22id%22:%22~j4g%22,%22name%22:%22%E2%8C%90%22,%22matrix%22:%22{{1,0},{0,1}}%22},{%22id%22:%22~3bl0%22,%22name%22:%22%C2%AC%22,%22matrix%22:%22{{1,0},{0,1}}%22}]}">Grover's Algorithm on 4 Qubits</a></li>
    </ul>
    <p>The bottom 4 qubits are the work qubits, which output the answer. The qubit above the work qubits is the |-⟩ qubit we use to add the negative phase, and the top qubit is used for labels. In this demonstration we have no classical query circuit (U<sub>c</sub>), we will create a query circuit and use it in the next section.</p>
        <p>Our algorithm searches for |0101⟩. Watch how the probability of measuring |0101⟩ grows with each iteration, and reaches 90.8% chance after two iterations. Classically (with random guessing) we would have a ~13% chance of getting |0101⟩ after two guesses.</p><br>
    <h3 style="text-align: center"><a href="using_grovers_algorithm.html">Next Section</a></h3>
    <p><br></p>
    </div>
  </body>
</html>