<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- /Bootstrap CSS -->
    <link rel="stylesheet" href="/Bootstrap/css/bootstrap.css" media="screen">

    <title>Grover's Algorithm: Exploiting Structure | CNOT</title>
	<link rel="icon" type="image/x-icon" href="/favicons/favicon.ico">
  </head>
  <body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <a class="navbar-brand" href="/">CNOT</a>
        <a href="/navigation/">
        <button class="navbar-toggler"  type="button" data-toggle="collapse" data-target="#navbarTogglerDemo01" aria-controls="navbarTogglerDemo01" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button></a>
  <div class="collapse navbar-collapse" id="navbarTogglerDemo01">
    <ul class="navbar-nav mr-auto mt-2 mt-lg-0">
      <li class="nav-item">
        <a class="nav-link" href="/get_started/">Get Started</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="/about/">About</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="/contents/">Contents</a>
      </li>
    </ul>
    </div>
    </nav>
    <div class='container'>
    <h1>Grover's Algorithm</h1>
    <p><br></p>
    <br>
    <h3>Summary</h3>
    <p>
        Grover’s algorithm is a search algorithm for unstructured databases. It is provably optimal for quantum computers, and quadratically faster than the best classical algorithm. Lov Grover published his algorithm in <a href="https://arxiv.org/abs/quant-ph/9605043">“A fast quantum mechanical algorithm for database search” (1996)</a>
    </p>
    <p>This page sets up unstructured search as a problem to be solved by Grover’s Algorithm, describes the algorithm’s basic operating principles, and takes the reader through a full example that uses the algorithm to solve NP-Complete problems.</p>
    <p><br></p>
    <h3>Contents</h3>
        <ol>
            <li><a href="#preamble">Preamble</a></li>
                <ul>
                    <li><a href="#unstructured_search">Unstructured Search</a></li>
                    <li><a href="#thinking_like_a_computer">Thinking like a Computer</a></li>
                </ul>
            <li><a href="#grovers_algorithm">Grover's Algorithm</a></li>
                <ul>
                    <li><a href="#outline">Outline</a></li>
                    <li><a href="#implementing_as_a_quantum_circuit">Implementing as a Quantum Circuit</a></li>
                    <ul>
                    <li><a href="#the_oracle">The Oracle</a></li>
                    <li><a href="#the_diffusion_operator">The Diffusion Operator</a></li>
                    <li><a href="#full_quantum_circuit">Full Quantum Circuit</a></li>
                    <li><a href="#quirk_example_circuit">Example Circuit in Quirk</a></li>
                    </ul>
                </ul>
            <li><a href="#using_grovers_algorithm">Using Grover's Algorithm</a></li>
            <ul>
                <li>Computational Search</li>
                <li>Example: SAT Problems</li>
                <ul>
                    <li>SAT Problems</li>
                    <li>Building an Oracle</li>
                </ul>
            </ul>
        <li>More about Quantum Search</li>
            <ul>
                <li>Search for Unknown Number of Solutions</li>
                <li>Something Else?</li>
            </ul>
        <li>Exploiting Structure</li>
            <ul>
                <li>Combining with Classical Algorithms</li>
                <li>Nested Quantum Search</li>
            </ul>
        </ol>
    <p><br></p>
    <h2 id="preamble">Preamble</h2>
    <h3 id="unstructured_search">Unstructured Search</h3>
    <p>
    A phonebook is an example of a structured database; Since a phonebook is sorted alphabetically, if given a name, we can quickly (in logarithmic time) locate that person’s phone number. Even if the phonebook has a large number of entries we can still find the name we’re looking pretty quickly. We will cover structured search in it’s own dedicated section.
    </p>
    <br>
    <div class="row">
    <div class="mx-auto text-center">
        <img src="img/fig1.png" style="width:85%" alt="Finding a name from a phone number is a difficult task, even with a relatively small phonebook." >
    </div>
    </div>
    <br>
    <p>
    But if we turn the problem around, i.e. we are given a phone number and asked to find it’s corresponding name, the search problem suddenly becomes very difficult. We can make no educated guesses about where the number we’re looking for might be. The best classical algorithm for unstructured search is ‘random guessing’, where we pick out entries at random until we happen upon the phone number we’re looking for. This algorithm grows linearly with the number of entries (N) in the phonebook, since it will take (on average) N/2 queries of the database to find the correct entry.
    </p>
    <br>
    <h3 id="thinking_like_a_computer">Thinking about Unstructured Search like a Computer</h3>
    <p>
    Since there is absolutely no way to search a real phonebook using Grover’s algorithm, we need to think about database search like a computer scientist. Firstly, to help ease the transition to quantum circuits, we will assume the names and numbers in our phonebook are stored in binary, and we will call them ‘inputs’ and ‘outputs’ respectively. Now note that the number of entries we have in our database (N) is related to the number of bits (n) by N = 2<sup>n</sup>.
    </p>
    <br>
    <div class="row">
    <div class="mx-auto text-center">
        <img src="img/fig2.png" style="width:90%" alt="Database as an input / output table. This is analogous to a phonebook" >
    </div>
    </div>
    <br>
    <p>
    By convention, we call the output we’re looking for ‘ω’.
    </p>
    <h3 id="the_query_circuit">The Query Circuit</h3>
    <p>
    The query circuit is a function that takes an address (the name) as input, and outputs the data at that address (the phone number). At the moment we treat the query circuit as a ‘black box’, which means we do not care about how it works, but we will do later. 
    </p>
    <br>
    <div class="row">
    <div class="mx-auto text-center">
        <img src="img/fig3.png" style="width:90%" alt="The query circuit checks the database and outputs the data at the input's address." >
    </div>
    </div>
    <br>
    <p>To perform a random guessing search, we input random addresses into the query circuit and check the output, repeating with different binary strings until the output equals the data we’re looking for. We add a ‘checker’ circuit that flips a ‘flag’ bit if our output is ω.</p>
    <br>
    <div class="row">
    <div class="mx-auto text-center">
        <img src="img/fig32.png" style="width:90%" alt="We add a checker circuit to flip a bit if our input is correct." >
    </div>
    </div>
    <br>
    <p>Using our phonebook analogy, we put random names into the query circuit until it outputs the phone number we were given. This algorithm has a complexity of order 2<sup>n</sup> (exponential time).</p>
    <br>
    <h2 id="grovers_algorithm">Grover's Algorithm</h2>
    <h3 id="outline">Outline</h3>
    <p>Here we will quickly describe Grover’s algorithm in a high-level way.</p>    <p>
    The first step of the algorithm is to initialise the starting state |s⟩, a superposition of all possible inputs. We know this can be easily accomplished using a Hadamard transform on each qubit.</p>
    <p><br></p>
    <div class="row">
    <div class="mx-auto text-center">
        <img src="img/fig4.png" style="width:100%" alt="The intital state is an equal superposition of all measureable inputs, and is easily constructed from Hadamard transforms." >
    </div>
    </div>
    <br>
    <p>Since we want our algorithm to output ω, we want our qubits to be as close to the state |ω⟩ as possible when we measure them. The algorithm is tasked with moving the state of the qubits from |s⟩ to |ω⟩. To simplify, we can split every state in our computation into one of two categories: |ω⟩ and not |ω⟩. Since we only care about |ω⟩ and all the states that are not |ω⟩, we can plot this on a 2D graph:</p>
    <br>
    <div class="row">
    <div class="mx-auto text-center">
        <img src="img/fig5.png" style="width:80%" alt="Our qubits start in the state |s⟩, and we are trying to get to |ω⟩" >
    </div>
    </div>
    <br>        
    <p>Where |s’⟩ is the equal superposition of all states excluding |ω⟩. This means |s’⟩ is perpendicular to |ω⟩. Our computer is never actually in the state |s’⟩ (if it is then we’re doing something very wrong!), we just use |s’⟩ to act as the axis on our graph, and to illustrate the reflections we are doing.</p>
        <p>We perform a reflection around |s’⟩ (this operator is called ‘U<sub>ω</sub>’) and a reflection around |s⟩ (called ‘U<sub>s</sub>’), and repeat until we are close to |ω⟩. This takes &nbsp; ~2<sup>n/2</sup> repetitions.</p>
    <br>
    <div class="row">
    <div class="mx-auto text-center">
        <img src="img/fig6.png" style="width:90%" alt="The first step of Grover's algorithm is to give a negative phase to the |ω⟩ component of |s⟩, this corresponds to a reflection through |s'⟩. The second step is to perform a reflection through |s⟩" >
    </div>
    </div>
    <p><br></p><br>    
    <h3>Implementing Grover's Algorithm as a Quantum Circuit</h3>
    <p>Here we will go through each step and show how they can be performed by a universal quantum computer. The first step, initialising the state |s⟩ is very simple: We do a Hadamard transform (H-gate) on each qubit, this gives us a uniform superposition of every state.</p><br>

    <h3 id="the_oracle">The Quantum Oracle</h3>
    <h5>(A very cool title)</h5>
    <p>The second operation, the reflection around |s’⟩ is the most interesting step, this is where our query circuit comes in. To perform the reflection, we need a circuit that adds a negative phase to the |ω⟩ component of our vector. </p>
    <p>Firstly, we implement our classical query circuit as a quantum circuit, (how we actually do this depends on the problem and we will cover this later,) this means we can pass it our superposition of inputs to get a new equal superposition of output states.</p>
    <p>And use our checker circuit to add a negative phase to the state we’re searching for. In the image below, our |ω⟩ is the state |1010⟩. This is easy enough to check for, we just use a Toffoli gate with the appropriate controls.</p>
    <p>But how do we apply the negative phase? Remember that if we apply an X-gate to a qubit in the |-⟩  state, we get back a qubit in the state -|-⟩:</p>
    <p>So we use our checker circuit to apply an X-gate to a |-⟩ qubit. We then reverse the classical query circuit to get back our initial |s⟩, except the |ω⟩ component is negative.</p>
    <p>We describe the combined state of the search qubits and the |-⟩ qubit using the Kronecker product (link to section). This explains how the negative phase introduced with the checker circuit applies to the whole state:</p>
    <p>And remember that any states that are not |ω⟩ will not activate the checker circuit and will pass through unaffected. This whole circuit is a functioning oracle, it performs a reflection about |s’⟩ as specified in Grover’s algorithm.</p><br>
        
    <h3 id="the_diffusion_operator">The Diffusion Operator</h3>
    <p>The next step is the reflection through |s⟩, this step is actually really simple, and is the same for every database search. This reflection is called the ‘Diffusion Operator’. To perform the diffusion operator we need to invert anything perpendicular to |s⟩, and we do this following a similar method to the Oracle. </p>
    <p>We will do the transformation that turns |s⟩ into the all-zeroes vector |000..0⟩, and invert anything that is not |000..0⟩, before transforming back again. Before, we easily created |s⟩ by applying a H-gate to each qubit, if we want to go back the all-zeroes vector we just apply a H-gate to each qubit again.</p>
    <p>The whole diffusion operator looks like this:</p>
    <p>Note that we have applied a negative phase to all the states that are <i>parallel</i> to |s⟩, not perpendicular as we specified. Since global phase can be ignored (link to global phase), this is completely equivalent. We now have all the steps required to complete Grover’s algorithm.</p><br>
    <h3 id="full_quantum_circuit">As a full Quantum Circuit</h3>
    <p>We can combine our classical query circuit, checker circuit and diffusion operator to complete the first iteration of Grover’s algorithm:</p>
    <p>Simple! We then repeat this O(√<span style="text-decoration: overline">N</span>) times.</p><br>
    
    <h3 id="quirk_example_circuit">Example Circuit in Quirk</h3>
    <p>Here is an example circuit in Quirk</p>
        <ul style="font-family: 'Source Serif Pro', serif;"><li><a href="http://algassert.com/quirk#circuit={%22cols%22:[[1,%22H%22],[%22~q1m2%22,%22Z%22],[%22%E2%80%A6%22],[%22~5kpj%22,1,%22H%22,%22H%22,%22H%22,%22H%22],[1,1,%22Chance4%22],[%22~lba%22,%22X%22,%22%E2%97%A6%22,%22%E2%80%A2%22,%22%E2%97%A6%22,%22%E2%80%A2%22],[%22~j4g%22,1,%22H%22,%22H%22,%22H%22,%22H%22],[%22~iaka%22,%22X%22,%22%E2%97%A6%22,%22%E2%97%A6%22,%22%E2%97%A6%22,%22%E2%97%A6%22],[%22~3bl0%22,1,%22H%22,%22H%22,%22H%22,%22H%22],[1,1,%22Chance4%22],[%22~lba%22,%22X%22,%22%E2%97%A6%22,%22%E2%80%A2%22,%22%E2%97%A6%22,%22%E2%80%A2%22],[%22~j4g%22,1,%22H%22,%22H%22,%22H%22,%22H%22],[%22~iaka%22,%22X%22,%22%E2%97%A6%22,%22%E2%97%A6%22,%22%E2%97%A6%22,%22%E2%97%A6%22],[%22~3bl0%22,1,%22H%22,%22H%22,%22H%22,%22H%22],[1,1,%22Chance4%22]],%22gates%22:[{%22id%22:%22~5kpj%22,%22name%22:%22Create%20|s%E2%9F%A9%22,%22matrix%22:%22{{1,0},{0,1}}%22},{%22id%22:%22~q1m2%22,%22name%22:%22Create%20|-%E2%9F%A9%22,%22matrix%22:%22{{1,0},{0,1}}%22},{%22id%22:%22~lba%22,%22name%22:%22Oracle%22,%22matrix%22:%22{{1,0},{0,1}}%22},{%22id%22:%22~7b6l%22,%22name%22:%22Diffusion%20Operator%22,%22matrix%22:%22{{1,0},{0,1}}%22},{%22id%22:%22~iaka%22,%22name%22:%22Diffuser%22,%22matrix%22:%22{{1,0},{0,1}}%22},{%22id%22:%22~j4g%22,%22name%22:%22%E2%8C%90%22,%22matrix%22:%22{{1,0},{0,1}}%22},{%22id%22:%22~3bl0%22,%22name%22:%22%C2%AC%22,%22matrix%22:%22{{1,0},{0,1}}%22}]}">Grover's Algorithm on 4 Qubits</a></li>
    </ul>
    <p>The bottom 4 qubits are the work qubits, which output the answer. The qubit above the work qubits is the |-⟩ qubit we use to add the negative phase, and the top qubit is used for labels.</p>
        <p>Our algorithm searches for |0101⟩. Watch how the probability of measuring |0101⟩ grows with each iteration, and reaches 90.8% chance after two iterations. Classically (with random guessing) we would have a ~13% chance of getting |0101⟩ after two guesses.</p>
    </div>
  </body>
</html>