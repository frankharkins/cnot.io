<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- /Bootstrap CSS -->
    <link rel="stylesheet" href="/Bootstrap/css/bootstrap.css" media="screen">

    <title>Grover's Algorithm: Going Further | CNOT</title>
	<link rel="icon" type="image/x-icon" href="/favicons/favicon.ico">
  </head>
  <body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <a class="navbar-brand" href="/">CNOT</a>
        <a href="/navigation/">
        <button class="navbar-toggler"  type="button" data-toggle="collapse" data-target="#navbarTogglerDemo01" aria-controls="navbarTogglerDemo01" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button></a>
  <div class="collapse navbar-collapse" id="navbarTogglerDemo01">
    <ul class="navbar-nav mr-auto mt-2 mt-lg-0">
      <li class="nav-item">
        <a class="nav-link" href="/get_started/">Get Started</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="/about/">About</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="/contents/">Contents</a>
      </li>
    </ul>
    </div>
    </nav>
    <div class='container'>
     <h1><a href="../grover/" style="text-decoration: none">Grover's Algorithm</a></h1>
        <div class="btn-group btn-group" style="margin: 2em" id="list">
            <a href="using_grovers_algorithm.html" style="font-size: 1.2em" class="btn btn-default">Previous</a>
            <a href="../grover/" style="font-size: 1.2em" class="btn btn-default">Index</a>
            <a href="exploiting_structure.html" style="font-size: 1.2em; margin-left: .2em" class="btn btn-default"> Next</a>
        </div>
    <h2>More About Quantum Search</h2>
    <p>NOT DONE YET! THIS PAGE IS A COPY OF THE PREVIOUS ONE.</p>
    <p><br></p>
    <h3>Contents</h3>
        <ul id="list">
            <li><a href="#computational_search">Computational Search</a></li>
            <ul><li><a href="#np-complete_problems">NP-Complete Problems</a></li></ul>
            <li><a href="#sat_problems">SAT Problems</a></li>
            <ul>
                <li><a href="#background">Background</a></li>
                <li><a href="#what_is_a_sat_problem">What is a SAT Problem?</a></li>
            </ul>
            <li><a href="#building_a_sat_oracle">Building a SAT Oracle</a></li>
            <li><a href="#full_sat_solving_circuit">A Full SAT Solving Circuit</a></li>
        </ul>
    <p><br></p>
    <h2 id="computational_search">Computational Search</h2>
    <p>Until now we have described our oracle as querying a database. While we could in theory use a real database, such as phonebook, we would need to query it in superposition which would require specialised hardware which is beyond the scope of this site. Instead we will apply quantum search to computational problems.</p>
    <p>Say we have a function:</p>
    <p>And we want to find the value of x that gives a desired value of y, a solution to this problem is to use computational search; we search through all the possible values of x until we output y. </p>
    <p>This still behaves as a database search, the difference is that instead of querying an external database, we can do the computation f(x) right on our computer. An example of computational search could be path finding, where we try different paths and calculate their length until we find the shortest one, or solving sudoku puzzles by trying random combinations of variables until we find a solution. </p>
    <p>Note that both these problems have structure that can be exploited, if you have ever tried a sudoku you will know that there are much cleverer ways to solve it than random guessing, and that these methods are much quicker! We will discuss exploiting structure in (link to section)</p>
    <h3 id="np-complete_problems">NP- Complete Problems</h3>
    <p>NP-complete problems are defined as problems in which it is easy (polynomial time) to verify a solution, but difficult (exponential time) to find the solution. NP-complete problems are very important in computer science; you may have heard of P vs NP - a famous unsolved mathematical problem that asks whether a polynomial-time solution to NP-complete problems exists. Algorithms for solving NP-complete problems often involve some kind of computational search which makes them a great potential application for our quantum search. </p>
    <p><br></p>
    <h2 id="sat_problems">SAT Problems</h2>
    <p>We now introduce Boolean Satisfiability (SAT) as an example of a real computational problem that can be solved using quantum search. </p>
    <h3 id="background">Background</h3>
    <p>We will use Grover’s algorithm to solve SAT problems, a specific NP-complete problem. There is no known algorithm that solves an NP-complete problem in less than exponential time, but a solution can be verified in polynomial time.</p>
    <p>SAT was the first problem proven to be NP-complete, and due to this has been widely studied. SAT is not only useful for purely mathematical uses; encryption algorithms such as the Data Encryption Standard can be reduced to 3-SAT and SAT solvers can be used in protein design and circuit synthesis.</p>
    <h3 id="what_is_a_sat_problem">What is a SAT Problem?</h3>
    <p>SAT is short for Boolean Satisfiability. </p>
    <p>A SAT problem takes n variables which can be assigned either ‘True’ or ‘False’ (in our computer, our qubits are our variables, we use |1⟩ to represent ‘True’ and |0⟩ to represent ‘False’). </p>
    <p>A clause is a collection of literals, and a literal describes the assignment of a specific variable. For example the clause given below has three literals (the ¬ indicates a false literal, the ∨ is the Boolean ‘OR’ and demands that at least one clause must be satisfied):</p>
    <p>If at least one of these criteria are met, the clause is satisfied, so each clause can be seen as ruling out specific combinations of variable assignments. A solution is an assignment of the n variables that satisfies every clause. In a k-SAT problem there are m clauses, with k literals in each clause. The hardest SAT problems have a small (but none zero) number of solutions, these problems generally have a fixed ratio of m to n which depends on k, for 3-SAT this ratio is ∼ 5, so there are approximately 5 clauses per variable in a difficult 3-SAT problem.</p>
    <p>We can map each clause in a SAT problem to a k-input Toffoli gate. Since each clause rules out one combination of variables, we can flip a target bit if our clause is unsatisfied:</p>
    <h3 id="building_a_sat_oracle">Building a SAT Oracle</h3>
    <p>First we need to create our classical SAT query circuit. The simplest way we can do this is to have each clause flip a different ancillary |0⟩ qubit, and our checker circuit only acts if no clauses are unsatisfied. We then reverse our classical query circuit to get a complete oracle:</p>
    <p>We now have a circuit that only acts on the |-⟩ qubit if all clauses are satisfied – a functioning oracle! It must be noted that while this circuit works, it uses a large number of ancillary qubits; we discuss how we can optimise our circuits in (link to section).</p>
    <h2 id="full_sat_solving_circuit">A Full SAT Solving Circuit</h2>
    <p>We now have a working oracle, all we need to do is combine it with our diffusion operator and create our starting state, |s⟩:</p>
    <p>This example circuit has two clauses and two solutions (|001⟩ &amp; |101⟩). Note that we only needed one iteration to achieve 100% probability of measuring a solution.</p>
    <h2 id="considerations">Considerations</h2>
    <p>This example is intended to:</p>
    <ol style="font-family: 'Source Serif Pro', serif;">
        <li>Show how quantum search can be useful, and provide some motivation for learning about quantum search.</li>
        <li>Give an example of converting real problems into quantum circuits.</li>
    </ol>
    <p>Unfortunately this SAT solver would not be very useful compared to modern classical SAT solver for a few main reasons:</p>
    <ol style="font-family: 'Source Serif Pro', serif;">
        <li>We don’t know how many solutions there are to each problem and we risk over-rotating and getting no useful answer at all.</li>
        <li>This search is naïve, or 'brute force' - we don’t exploit any structure.</li>
        <li>The number of ancillary qubits needed is very large (much greater than n).</li>
    </ol>
    <p>We will address each of these points and discuss how to overcome them in later section (link to sections)</p>
    <p><br></p>
    </div>
  </body>
</html>